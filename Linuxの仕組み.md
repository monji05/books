# はじめに

## Linux

正確に「Linux」という言葉はカーネルのみを指すが、本書ではUNIXライクなインターフェースを持つOSを便宜的にLinuxとする


# 1.Linuxの概要

## プログラムとプロセス

マシンの電源を入れると、最初にカーネルが起動する。
起動後に動作中のプログラムを **プロセス** という。
カーネルはハードウェアの助けを借りてプロセスからデバイスに直接アクセスできないようにしている。
具体的にCPUに備わるモードという機能を使う。
CPUがカーネルモードであればなんの制限もないのに対し、ユーザモードで実行中ならば特定の命令を実行できないようにする、のような制約をかけられる。
Linuxの場合はカーネルのみがこのカーネルモードで動作して、デバイスにアクセスできる。
それに対してプロセスはユーザモードで動作するため、デバイスにアクセスできない。
このため、プロセスは **カーネルを介して** デバイスにアクセスする。
つまり、システム内のすべてのプロセスが享有するリソースを一元管理して、システム上で動作するプロセスに配分する
そのためにカーネルモードで動作するプログラムが **カーネルである**。

## システムコール

システムコールとは、 **プロセスがカーネルに処理を依頼する** ための方法である。
新規プロセスの生成やハードウェアの操作など、カーネルの助けが必要な場合に使う。
- プロセス生成、削除
- メモリ確保、解放
- 通信処理
- ファイルシステム操作
- デバイス操作
  などがシステムコール。
  システムコールは、CPUの特殊な命令を実行することによって実現している。
  カーネルに処理を依頼するためにシステムコールを発行すると、CPUにおいて **例外というイベント** が発生する。
  これをきっかけとして、CPUのモードがユーザモードからカーネルモードに遷移し、依頼内容に応じたカーネルの処理が動き始める。
  システムコールが終われば、ユーザモードに戻りプロセスの動作を継続する。


## ライブラリ

多くのプログラミング言語では複数のプログラムに共通する処理をライブラリとしてまとめる機能がある。


## 標準Cライブラリ

C言語には国際標準化機能（ISO）によって定められた標準ライブラリがある。


## システムコールのラッパー関数

システムコールは通常の関数呼び出しと違ってC言語などの高級言語から直截呼び出せない。
アーキテクチャ依存のアセンブリコードを使って呼び出す必要がある。
libcは内部的にシステムコールを呼び出すだけのシステムコールのラッパーと呼ばれる一連の関数を提供している。
高級言語で書かれたユーザプログラムからは、各言語に対して用意されているシステムコールのラッパー関数を呼び出すだけで済む。


## 静的ライブラリと共有(動的)ライブラリ

プログラムの生成時にコンパイルしてオブジェクトファイルというファイルを作る。
そのうえでオブジェクトファイルが使うライブラリをリンクして実行ファイルを作る。
静的ライブラリはリンク時にライブラリ内の関数をプログラムに組み込む。
これに対して共有ライブラリはリンク時に「このライブラリのこの関数を呼び出す」といった情報だけを実行ファイルに埋め込む。
そのうえでプロブラムの起動時、あるいは実行中にライブラリをメモリ上にロードしてプログラムはその中の関数を呼び出す。


# 2.プロセス管理（基礎編）

## プロセスの生成

あたらしくプロセスを生成する目的は2つ。
    1. 同じプログラムの処理を複数のプロセスに分けて処理する。（例：webサーバーによる複数リクエストの受付）
    2. 別のプログラム生成する（例：bashから各種プログラムの新規作成）


## ゾンビプロセスと孤児プロセス

子プロセスが終了しても親プロセスが終了状態を得ていないという状態のプロセスをゾンビプロセスという。
システム起動中にゾンビプロセスが大量に存在している場合、親プロセスに対応するプログラムの **バグを疑う** といい。


## シグナル

あるプロセスが他のプロセスになにかを通知して、外部から実行の流れを強制的に変えるための仕組みである。


## シェルのジョブ管理の実現

ジョブとは、bashのようなshellがバックグラウンドで実行したプロセスを制御するための仕組み。
セッションはユーザがgtermのような端末エミュレータ、あるはsshなどを通してシステムにログインしたときのログインセッションに対応するもの。
すべてのセッションには、セッションを制御するための端末が紐づいている。
セッションにはセッションID、あるいはSIDと呼ばれる一意な値が割り振られている。
セッションリーダーというプロセスが１つ存在していて、通常はbashなどのshellになる。


## プロセスグループ

プロセスグループは、復数のプロセスをまとめてコントロールするためのもの。
セッションの中には復数のプロセスグループが存在する。


## デーモン

デーモンは常駐プロセスのこと。
普通のプロセスはユーザが立ち上げてから何らかの一連の処理をしてから終了することが前提。
デーモンはシステムの開始から終了まで存在し続ける。
デーモンの特徴は
- 端末から入出力する必要がないので、端末が割り当てられていない。
- あらゆるログインセッションが終了しても影響を受けないように、独自のセッションを持つ。
- デーモンを生成したプロセスがデーモンの終了を気にしなくていいように、initが親になっている。
  上記の条件に当てはまらないものも、常駐プロセスであれば便宜的にデーモンと呼ばれることもある。


# 3.プロセススケジューラ

システムに存在するプロセスは、ほとんどスリープ状態だが、ではシステムに複数の実行可能プロセスが存在する場合、カーネルはどのように各プロセをCPU上で実行させるのだろう？


## コンテキストスイッチ

論理CPU上で動作するプロセスが切り替わることをコンテキストスイッチという。
コンテキストスイッチは、プロセスがいかなるコードを実行中であろうとも、タイムスライスが切れると容赦なく発生する。
なので、例えばfoo()の直後にbar()が実行されるという保証はない。
foo()の実行直後にタイムスライスが切れた場合、bar()の実行はそのしばらくあとになる。
これを理解していると、ある処理の完了までに想定より多くの時間がかかってしまった場合に、「その処理自体に問題があるに違いない」と安易に結論づけるのではなく
「処理中にコンテキストスイッチが発生して他のプロセスが動いた可能性もある」という別の観点を持てる。


## 性能について

- ターンアラウンドタイム: システムに処理を依頼してから個々の処理が終わるまでの時間
- スループット: 単位時間当たりに処理を終えられる数
  応答性能重視のシステムは、スループット重視のシステムよりも、システムを構成する各マシンのCPU使用率を低めに抑える必要がある。
  論理CPUをたくさん積んでいるマシンがあったとしても、そこに十分な数のプロセスを実行させてはじめてスループットが向上する。
  むやみにプロセス数を増やしてもスループットは上がらない。


# 4.メモリ管理システム

## メモリ関連情報の取得

システムが搭載するメモリの量と使用中のメモリの量はfreeコマンドで得られる。


## 仮想記憶

仮想記憶はハードウェアとソフトウェア（カーネル）の連携によって実現している。

ページテーブル 仮想アドレス→物理アドレス
CPUがメモリをぺーじ単位で管理
ページテーブルエントリ 仮想アドレスと物理アドレスの対応表
ページのサイズはCPUアーキテクチャごとに異なる
ページテーブルはカーネルがつくる

**カーネル**
    - プロセス生成 ＋ プロセス用のページテーブル作成
      **CPU**
- プロセスが仮想アドレスへアクセス -> 物理アドレスへ変換

仮想アドレス空間は固定でページテーブルエントリにはページに対応する物理アドレスが存在するかどうかを示すデータがある。
なので、物理アドレスに紐づいていないアドレスにプロセスがアクセスすると、CPU上で **ページフォールト** という例外が発生する。
この例外によって、CPU上で実行中の命令が中断され、カーネールのメモリに配置された **ページフォールトハンドラ** という処理が実行される。

カーネルはページフォールトにおいてプロセスによるそのメモリアクセスが不正であることを検出する。
→SIGSEVというシグナルをプロセスに送信
→SIGSEVを受け取ったプロセスは強制終了させられる
その内容を実装したCの実行結果は **Segmention fault**



### 仮想記憶がないときの課題

仮想記憶がないときのメモリ管理には、以下のような課題がある。
- メモリの断片化
- マルチプロセスの実現が困難
- 不正な領域へのアクセス


#### メモリの断片化

プロセスが生成されたあとに、メモリの獲得、開放を繰り返すとメモリの断片化という問題が発生する。
例えば、300バイトも空いているのに、まとまっていないため、100バイトずつ３つの領域に分かれていると100バイトより大きな領域の確保に失敗する。


#### 不正な領域へのアクセス

カーネルやたくさんのプロセスがメモリ上に配置されている場合、あるプロセスがカーネルや他のプロセスに割当てられたメモリのアドレスを指定すればそれらの領域にアクセスできてしまう。
そのため、データの漏洩や破壊のリスクがある。


### 仮想記憶の機能

仮想記憶はプロセスがメモリアクセスする際にシステムに搭載されているメモリに直接アクセスさせるのではなく、仮想アドレスというアドレスを用いて間接的にアクセスさせるという機能。

#### ページテーブル

仮想アドレスから物理アドレスへの変換にカーネルのメモリ内に保存されている「ページテーブル」という表を使う。
ページテーブルを作るのはカーネル。


### 仮想記憶による課題の解決

- メモリの断片化
  プロセスのページテーブルをうまく設定すれば、物理メモリ上では断片化している領域を、プロセスの仮想アドレス空間上では大きな一つの領域として見せられる。
  これによって断片化の問題を解消される。

- マルチプロセスの実現が困難
  仮想アドレス空間はプロセスごとに作られるので、マルチプロセス環境において各プログラムは、ほかのプログラムとのアドレスの重複を避けられる。

- 不正な領域医へのアクセス
  プロセスごとに仮想アドレス空間があるということは、他のプロセスのメモリにはそもそもアクセスできないということ。
  あるプロセスから別のプロセスへの不正アクセスができなくなる。


## プロセスへの新規メモリの割り当て

1. メモリ領域の割り当て：仮想アドレス空間に新規にアクセス可能なメモリ領域をマップする。
2. メモリの割り当て： 上記メモリ領域に物理メモリを割り当てる。

**ページフォールトハンドラ**
- if ページテーブルエントリが存在する -> 物理アドレスが割り当てられていない場合 ->カーネルが新規メモリを割り当てる
- if ページテーブルエントリが存在しない -> SIGSEVをプロセスへ


## ページテーブルの階層化

ページテーブルはメモリ使用量を削減するために階層化される

**ヒュージページ**
通常サイズより大きいページでメモリ削減できる。
データベースや仮想マシンマネージャなど仮想メモリを大量に使うソフトウェアにはヒュージページを使う設定が用意されている。


# 5.プロセス管理

## プロセス間通信

- 復数のプログラムを強調動作させるにはお互いの処理のタイミングを合わせる（同期させる）必要がある。
  このためにOSが提供する機能を **プロセス間通信** という。
- シグナルもプロセス間通信のひとつ。

**ソケット**
復数のプロセスを「ソケット」と呼ばれるもので繋いで通信。
- UNIXソケット
  1つのマシン上のプロセスのみを通信させる方法。
- TCPソケット、UDPソケット


## 排他制御

システム上に存在するリソースは同時にアクセスされてはいけないものが多い。
例えば同時にaptが動作できると、パッケージ管理のデータベースが破壊されてしまう。

**クリティカルセクション**
同時に実行されると困る一連の処理
**アトミック処理**
システムの外から見て一連の処理に見える処理


## マルチプロセスとマルチスレッド

プログラムを並列に動作させる方法
1. 全く別の復数のプログラムを同時に動かす
2. ある目的をもった1つのプログラムを復数の流れに沿って分割して動かす
   2を大別するとマルチプロセスとマルチスレッドに分けられる

**マルチプロセス**
必要な数のプロセスを生成して、プロセス間通信をしながら処理する


# 6.デバイスアクセス

- デバイスファイルはデバイスごとに存在する
- Linuxではプロセスがデバイスファイルを操作すると、カーネルの中のデバイスドライバというソフトウェアがユーザーの代わりにデバイスにアクセスする。
- デバイスファイルにアクセスするのは通常rootだけ。
- プロセスは通常のファイルと同じようにデバイスファイルを操作できる。
  つまり、システムコールからデバイスファイルにアクセスできる
- デバイスファイルには次の情報が保存されている
  ファイルの種類: キャラクタデバイス or ブロックデバイス
  デバイスのメジャー番号、マイナー番号
  行頭の文字がcならキャラクタデバイス、bならブロックデバイス

**キャラクタデバイス**
キャラクタデバイスは読み出しと書き込みはできるが、デバイス内でアクセスする場所をシークできない。

**ブロックデバイス**
ブロックデバイスはファイルの読み書き以外にシークできる


## デバイスドライバ

デバイスを直接操作するにはデバイスファイルを介してレジスタという領域にアクセスする。
CPUのレジスタとは **別のもの**


## メモリマップトI/O（MMIO）

現代的なデバイスはMMIOという仕組みでデバイスのレジスタにアクセスする


## ポーリング

ポーリングは、デバイスドライバが能動的にデバイスの処理が完了したかどうかを確認する


# 7.ファイルシステム

## メモリマップトファイル

Linuxにはファイルの領域を仮想アドレス上に空間場にmapする **メモリマップトファイル** という機能がある
メモリマップしたファイルには目盛りと同じ方法でアクセスできる


## 容量制限(クォータ)

用途ごとに使用できるファイルシステムの容量を制限する機能


## ジャーナリングによる不整合の防止

ファイルシステムの中にジャーナリングという領域を設け、更新するファイルをそのジャーナルに書き込む、この一覧をジャーナルログという
そのジャーナルに従って実ファイルの更新をする
ジャーナルログがあることで、実ファイルの更新中に強制終了させられてもジャーナルログをもとに再度更新できる
ジャーナルログを書き込む途中で強制終了させられても、そのジャーナルログを捨てるだけでいい


## コピーオンライトによる不整合防止

コピーオンライト型のファイルシステムはいったんファイルシステムにデータを書き込んだあとは別の場所にデータを書き込む、その後にリンクを張り替える


## スナップショット

スナップショットの作成はデータのフルコピーではなく、データを参照するメタデータの作成をする
root/にfoo,barファイルがあるとすると、スナップショットのrootからはfoo,barへのリンクが貼られるだけ
スナップショットは実ファイルのデータを共有しているので、実ファイルが壊れたらスナップショットも壊れるので、バックアップとして使うのは不向き


## その他のファイルシステム

ストレージデバイスにメモリ上に作成する **tmpfs** というファイルシステムがある
メモリ上なので当然電源が切られればその情報は消えるが、ストレージへのアクセスがない分高速にアクセスできる


## procfs

システムに存在するプロセスについての情報を得るために **procfs** というファイルシステムがある
通常procfsは/proc以下にマウントされる


# 8.記憶階層

## キャッシュメモリ

CPUの動きを単純化させると、
1. 命令を読み出して、命令の内容を下に目盛りからレジスタにデータを読み出す
2. レジスタ上のデータを下に計算する
3. 計算結果をメモリに書き戻す
   1,3の処理は2に比べ遅いので、それを解消するキャッシュメモリがある
   キャッシュメモリは通常CPUの中に存在する高速な記憶装置
   CPU→キャッシュメモリのアクセスはメモリへのアクセスに比べて数十倍高速
   メモリからレジスタにデータを読み出すとき、まずキャッシュメモリに **キャッシュライン** という単位でデータを読み出したうえでそのデータをレジスタに読み出す
   この処理は **ハードウェアが行うもの** で、カーネル関与しない


## ダーティである

メモリアドレス300にあるデータをCPUがアクセスして、R0レジスタに書き込むとする
このときすでにキャッシュメモリにそのデータが書き込まれている状態
そうすると、CPUがR1レジスタに同じアドレスのデータにアクセスするとき、キャッシュメモリにアクセスするので高速化できる
その状態で、R0のデータを変更したとき、キャッシュラインにはメモリから読み出してからデータが変更されたことを示す印をつける、これを **ダーティである** と表現する
マークされたキャッシュラインのデータをメモリに反映すれば、そのキャッシュラインのデータはダーティではなくなる（そりゃそうだ）
このメモリへ書き戻す方法に **ライトスルー方式** と **ライトバック方式が** ある

**ライトスルー方式**
キャッシュメモリに書き戻すときに一緒にメモリにも書き戻す
**ライトバック方式**
キャッシュメモリに書き戻すが非同期にメモリに書き戻す
メモリにアクセスしないので、ライトバック方式の方が速い


## スラッシング

キャッシュメモリが一杯の状態でキャッシュに存在しないデータを読み取るとキャッシュラインのうちの一つを削除し、空いた場所にいれる
破棄されたキャッシュラインがダーティであった場合、メモリに書き込んでから消される
キャッシュに存在しない領域へのメモリアクセスが頻発すると、キャッシュラインのデータの入れ替わりが激しくなり、 **スラッシング** という状態になり、性能が劣化する


## 参照の局所性

メモリアクセスせず、キャッシュにしかアクセスしないケースは実際頻発する

**時間的局所性**
ある時点でアクセスしたメモリは近い将来再びアクセスする可能性が高い
典型的なのはループ処理内のコード

**空間的局所性**
ある時点でアクセスすると近い将来、それに近い場所のデータにアクセスする可能性が高い
典型的には配列要素への全走査における配列のデータ


## Simultaneous Multi Threading(SMT)

CPUの処理時間よりもメモリアクセスの所要時間の方が遥かに長いので、CPUのリソースを有効活用できるハードウェアの機能に **SMT** がある


## ページキャッシュ

- CPU→メモリへのアクセス速度に対してストレージへのアクセスはHDDだと1000倍以上遅い
  これを解消するためのカーネルの仕組みが **ページキャシュ**
- ページキャッシュは **ファイルのデータ** をメモリにキャッシュする
- ページキャッシュはページ単位でデータを扱う
- その他ダーティなページを表す **ダーティページ**、ダーティページのディスクへの書き込みを行う **ライトバック** という概念がある
- プロセスがファイルのデータを読み出すとカーネルはカーネル自身のページキャッシュという領域にコピーしてから、プロセスのメモリにコピーする
- カーネルは他のプロセスなどがそのデータを読み出すとき、ストレージまでアクセスしないため高速化できる
- キャッシュメモリのバックスルー方式と同じようなライトバック方式もある
- ページキャッシュ上にダーティなページが有る状態でマシンの電源が落ちた場合、そのデータはなくなる


## バッファキャッシュ

- バッファキャッシュはディスクのデータのうち、ファイルデータ **以外** のものをキャッシュする仕組み
- バッファキャッシュの用途
        - ファイルシステムを使わずにデバイスファイルを用いてストレージデバイスに直接アクセスするとき
        - ファイルのサイズ、種類などのメタデータにアクセスできる


## スワップ

物理メモリがなくなるとOOMという状態になる
**スワップ** を使えばストレージの一部を一時的にメモリの代わりとして使う仕組み
具体的にはシステムの物理メモリが枯渇した状態で更にメモリを獲得しようとするとこのときの退避領域を **スワップ領域** と呼ぶ
カーネルがスワップすることをページアウト（あるいはスワップアウト）


# 10.仮想化機能

仮想化ソフトウェア
- KVM(Kernel based Virtual Machine) カーネルが提供する仮想化機能


## 仮想マシンとの違い

仮想マシンは個々の仮想マシンは専用の仮想的なハードウェアとカーネルを使うのに対し、コンテナの場合コンテナを動かすホストOS,及び全コンテナが1つのカーネルを共有する
そのため、仮想マシンではwindowsのような、Linuxとは完全に異なるホストOSを動かせるのに対し、コンテナはLinuxカーネル上で動作するシステムのみ動かせる
コンテナ上にUbuntu20.04環境を作る場合、コンテナランタイムと呼ばれるプロセスがコンテナを作ったうえで最初のプロセスを起動させるだけ
なので、コンテナは仮想マシンと比べて以下の点で軽量
- 起動速度 コンテナにおいては仮想マシンにおける最初の処理を省略できる
- ハードウェアのアクセス速度 仮想マシンはハードウェアアクセスによって物理マシン制御するのに対し、コンテナにはそれがない


# 11. コンテナ

## namespace

カーネルには **コンテナ** という機能はない
カーネルは **namespace** 機能を使って実現している
namespaceはシステムの様々なリソースに存在し、プロセスには **見かけ上** は独立したリソースを見せる機能

### pid namespace (pid ns): 独立したpid名前空間を見せる

システム起動時にはすべてのプロセスが所属する **root pid ns** (rootとする)というものが存在する
そこからの子である pid ns(fooとする)から親のrootのプロセスは見えない rootからは見える
子同士のプロセスはお互いが見えない

### user namespace (user ns): 独立したuid, gidを見せる


### mount namespace (mount ns): 独立したファイルシステムマウント状況を見せる



## コンテナの正体

namespaceをもつことによって **他のプロセスと実行環境が分かれている１つないし複数のプロセス**、これがコンテナである
コンテナの正体がわかったところで、もう一つわかったことがある
ホストOSや他のコンテナに起因する問題がある場合、コンテナの中からは原因がわからないということ
別のコンテナに原因があったとしても、それが違うコンテナ内ではその中のプロセスしか把握していないので、わからない


## セキュリティリスク

コンテナとホストOSはカーネルを共有するので、悪意を持ったユーザーによってホストOSあるいは他のコンテナの情報を盗み見られるリスクがある
対して仮想マシンは共有していないので、仮想マシン上のハードウェアに被害がとどまる
その問題を避けるためにいろいろなコンテナランタイムが存在する
- Kata Container
- gVisor


# 12.cgroup

cgroupはシステムのメモリやCPUなどのリソースを **どのプロセスにどれだけ与えるか** という細かい制御をするための機能
「プロセスをgroupに分けて各種リソースを制御するcontrol」が名前の由来


## cgroupが制御できるリソース

cgroupではリソースごとにコントローラというカーネル内プログラムが存在し、それぞれのリソースを制御する
- cpuコントローラ
- memoryコントローラ
- blkioコントローラ
- ネットワークコントローラ
  それぞれのコントローラは **cgroupfsという特別なファイルシステム** を介して使う

