@document.meta
title: プログラミングGauche
description: 関数型プログラミングを勉強するために、小川さんからお薦めいただいた書籍
categories: 関数型プログラミング
created: 2023-09-17
version: 1.0.0
@end

* プログラミングGauche
  Weather: Sunny 
  {:2023-09-16:}[Yesterday] - {:2023-09-18:}[Tomorrow]
** 1.LispとScheme
*** LISPの起源
**** リストを処理するシステムだったので、LISt Programmingの頭文字を取って *LISP* と呼ばれた
*** S式と前置記法
**** S式はリスト構造を表記するために考案した構文
    (\<手続き\> \<引数1\> \<引数2\> ...)
    前置記法は
    @code scheme
    (+ 1 (/ (* 2 3) 4))

    S式はカッコの入れ子を使って木構造を簡単に表現できる
    (+1 
      (/ (* 2 3)
      4)
    )
    @end

*** Scheme
    Schemeはもともと並行プログラミングにおける制御構造の理論を検証するための小さなインタプリタで、それ自身がLispで書かれている
    SchemeはLISPとは逆に言語仕様を単純で直交する少数のルールで表現した
    最も基本のルールは以下の二つ
    - lamda式は「レキシカルな環境を保持した手続き」（クロージャ）へと評価される
    - 手続き呼び出しは継続を伴った引数つきgotoである
    このルールを理解することが、Schemeを理解することそのものだからめちゃくちゃ大事

*** Gauche
    Schemeの原理的な単純さと強さを保ちながら、日常の実用的な問題を素早く解決できる処理系がほしい、そんな願いから、Gaucheが生まれた

** 2.Gaucheの特徴
  Gaucheは次の点を念頭において設計された
  - 手軽にプログラムを書いて試せるスクリプト処理(インタプリタ？)系であること
  - 実用規模のプログラムにまで機能、性能ともにスケールすること
  - 他の言語で書かれたアプリケーションに埋め込み可能であること

** 3.Gaucheの設計思想や誕生の背景
*** Perlの影響
    GaucheはScheme言語処理系だが、PerlとCommon Lispの影響をかなり受けている
    Perlから受けた代表的なものは以下
    - 正規表現リテラル
    - 文字列補間
    （補間とは、データ列の各区間の範囲内を埋める数値を求めること、またはそのような関数を与えること）
    - モジュールシステム
    - DBI/DBD

*** Common Lispの影響
    代表的に影響を受けたもの
    - キーワード引数
    - オブジェクトシステム(CLOS) 17章「総称関数とオブジェクト」にて
    - コンディション 10章「テスト例外処理」にて
    キーワード引数は可変長引数の一種である特定の意味を占めすキーワードを引数にとることができる

** Gaucheの基礎練習
  真値は*t,偽値は*fと表記する
  読み書き不変性とは、読んだ通りに出力されること

** 手続き呼び出し
  schemeでは(+ 1 2)と書く
  式の値を変数に格納するときは
  @code scheme
    (define sqrt2 (sqrt 2))
    (define <変数名> <式>)と書く
  @end

** 6.リスト
*** リストの基本操作
    手続きcarは、先頭の要素を、cdrは先頭を除いた残りの要素を返す
    car, cdrと逆の操作で、先頭要素と残りの要素からなるリストをくっつけてリストにするのはcons
    @code scheme
      (car '(1 2 3)) ;1
      (cdr '(1 2 3)) ; (2 3)
      (cons 1 '(2 3)) ; (1 2 3)
      ;なので以下にすると元のリスト（1 2 3） になる
      (cons (car '(1 2 3)) (cdr '(1 2 3))) ;(1 2 3)

      consの２番目の引数にリストでないものを与えたらどうなるか
      (cons 1 2)
      ; (1 . 2)
      これはドット対（dotted pair）と呼ばれている
      いくつか対が連なって最後が空リストで終わっていない場合はドットリスト（dotted list）と呼ばれる
      ドット対はドットリストの特別な場合である

      手続きnull?は引数が空リストであれば真値を、そうでなければ偽値を返す
      真偽値を返す手続きに?で終わる名前をつけるのはschemeの慣習

      (null? '(1 2 3))
      ;*f
      (null? '())
      ;*t

      手続きpair?は引数が空でないリストであれば真値を、そうでなければ偽値を返す
      (pair? '(1 2 3))
      ;*t
      (pair? '())
      ;*f
    @end
    これら５つの手続きはリスト操作の最も基本となる手続きで、これらを組み合わせることでさまざまなリスト処理手続きが定義できる

*** リストの走査
    リストの要素を順に処理していく手続きの基本になるのはfold
    @code scheme
    (fold <手続き> <初期値> <リスト>)
    <リスト>が要素(v0 v1 v2 ... vN)からなるとき、foldは次のとおりに動作する
    - まず、最初の要素v0と<初期値>を引数にして<手続き>を呼ぶ
    - 次に、2番目の要素v1と上の呼び出しの結果を引数にして、<手続き>を呼ぶ
    以下同様に繰り返し、最後にvNとそれまでの結果を引数にして<手続き>を呼び、その結果をfoldの戻り値とする
    もし<リスト>が空リストであれば、<初期値>がそのまま返される

    次の例は与えられた数のリスト(1 2 3 4 5)の合計を計算する
    (fold + 0 '(1 2 3 4 5)) ;15
    foldは「次の式の値を求める」と説明できる
    (+ 5 (+ 4 (+ 3 (+ 2 (+ 1 0))))); 15
    @end

    数のリストのうち、最大のものを求めるmax-numberはどうやって定義するか
    まず、２つの数の引数で大きい方を返す手続きは次の通り
    @code scheme
    (define (pick-greater a b)
    (if (> a b) a b); (if <条件式> <条件が真の時に評価される式> <条件が偽の時に評価される式>)

    確かめる
    (pick-greater 2 4);4
    @end

    初期値は、最初のpick-greaterの呼び出しで、確実に第1引数が返される必要がある
    なので、負の無限大を返す
    正の無限大と負の無限大はそれぞれ+inf.0, -inf.0と表記する
    pick-greaterは、max-numberの中でしか使わない
    こういった補助手続きは、その手続きの中に定義を書いておくことができる
    @code scheme
    (define (max-number lis)
      (define (pick-greater a b))
        (if (> a b) a b)
      (fold pick-greater -inf.0 lis))
    @end
    手続き内定義は、その手続きの本体を構成する式よりも前に置く必要がある


