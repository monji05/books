@document.meta
title: 単体テストの考え方
description:
categories:
created: 2023-11-23
version: 1.0.0
@end

2023.12.01 読了
* 1.2 なぜ、単体テストを行うのか？
  Q.単体テストをすることで、何を成し遂げたいのか
  A.プロジェクトの成長を持続可能なものにする
  開発スピードが急に落ちる現象はソフトウェア・エントロピーの増加によって起こる
  (エントロピーとは無秩序の量のこと)
  リファクタリングなど適切な処理を常にしていかなければ、そのソフトウェアはすぐに複雑になっていき、無秩序になっていく
  そうなると、１つのバグを修正したつもりが、より多くのバグを生み出してしまったり、デグレを引き起こしてしまう。
  しかし、単体テストがあれば、それを防ぐことができる。
  コードの変更によって生じる多くの退行（regression）を検出するセーフティ・ネットがプロジェクトに備わることになるから。
  退行（regression）とは、特定のイベントが発生したあと（通常はコードに変更を加えたあと）、意図したように機能しなくなること。
  退行とバグは同じような意味を持つ。

  - テストコードもまた、他のコードと同じようにバグに対して脆弱であり、保守を必要とするものである。

* 1.3 網羅率(coverage)とテストスイートの質との関係
  カバレッジ（網羅率）の計測において非常によく使われる単語
  - コードカバレッジ
  - 分岐カバレッジ
 ** コードカバレッジ
    コードのカバレッジの算出方法は、コードの総数に対してのテストコードの総数の割合のこと
    つまりリファクタリングをしてコードを短くすればするほど、テストコードのカバレッジは上がってしまう。
    それはテストスイートの質が上がったわけでは当然ない（テストコードを変更していないのだから）
    （テストスイートとは目的や対象ごとにテストケースを集めたもの）
    なので、あくまでの指標としてみるだけで100%を目標にしない
 ** 分岐カバレッジ
    コードの分岐(if,else)に目を向けているのでコードカバレッジよりも正確な網羅率の計測ができる

  しかし、カバレッジではテストの質を評価することはできない
    - 実際のテスト対象のコードが検証されたのかを保証できないため
    - 使用するライブラリ内のコードは計測の対象から外れるため
  
* 1.4 何がテスト・スイートの質を良くするのか？
  ** 単体テストにかける労力をシステムによって非常に重要な部分に向ける
    つまりビジネスロジックの部分、つまりドメインモデルになる
    そのため、テストに費やした時間が価値がでるのはビジネスロジックに対するテストということになる。
    一方、ドメインモデルではないコードには次の３つのコードがある。
     - インフラに関するコード
     - 外部サービスや依存関係にあるもの（たとえばデータベースやサードパーティのシステム）
     - 構成同士を結びつけるコード
    だから、ドメインモデルをアプリケーションの他の関心事から隔離しておけば、単体テストにかける労力をドメインモデルにのみ向けられる
    その詳細は第2部で

* 2. 単体テストの定義
** テストダブル
   リリース対象のオブジェクトと同じような見た目と振る舞いを持っていながらも、複雑さを減少させて簡潔になることでテストを行いやすくするオブジェクトのこと

** テストダブルを使うことの利点
   テスト対象の依存は全てテストダブルに書き換えられているため、テストが失敗した時、テスト対象システムだけを問題を起こした対象として見られるようになるから

** テスト・ダブルを使う判断は対象の依存が可変かどうか
   もし依存がイミュータブルであれば、その依存はテスト・ダブルに置き換える必要はない

** 値オブジェクト
   C#の列挙型や不変オブジェクトのこと、（product.shampoo,5...）単純に値ともいう
   PHPでいうとクラスのプロパティのことかな

** 共有依存
   テストケースの間で共有される依存のこと(クラス間での共有ではない)
   ex)クラスの静的(static)なフィールド,可変なデータベース

** プライベート依存
   共有されない依存

** プロセス外依存
   プロセス間で共有される依存
   ex)データベース
   ただし、データベースが常に共有依存だとは限らない

** 良い単体テストとは
   *単体の定義* とは、１単位の振る舞いの検証をする（問題領域においてビジネスサイドの人が有用であると考える何か）こと
   だからそれを検証するために１クラスで終わることもあれば、クラスをまたがっていることもあれば、１メソッドで終わることもある
   だからコードの粒度を細かくしようとしても単体テストにおいてはあまり有用ではない
   単体テストにおいてすべきことは、そのテストに関わる人たちにテスト対象のコードが解決しようとしている物語（story）を伝えること
   伝えるためには凝集度(cohesion)を高め、非開発者でも理解できるようにする必要がある

   - 凝集度が高い文章: 何を伝えようしているのか明確
    私が犬の名前を呼ぶと、その犬は私のところに寄ってきます
   - 凝集度が低い文章: 何をしているのか曖昧
    私が犬の名前を呼ぶと、その犬は左前足を動かし、次に右前足を動かし、頭を私の方に向け、尻尾を振り始め。。。（略）

*** テスト駆動開発(TDD)
    ~ 追加する機能がどのように振る舞うのかを示すテストケースを作成し、そのテストケースが失敗することを確認する
    ~ テストが成功するのに必要なプロダクションコードを書く、この時点ではコードを洗練する必要も、簡潔にする必要もない
    ~ 実装しコードに対して、リファクタリングを行う。既に振る舞いが正しいことをテストが保証しているので安全にリファクタリングできる
      その結果、プロダクションコードはさらに読みやすくなり、保守も行いやすくなる


*** 統合テスト
    古典学派とロンドン学派の間で統合テストの定義も異なる
    ロンドン学派では実際の協力者オブジェクト（collabolator）を使って行うテストを全て *統合テスト* とみなす
    なので古典学派のスタイルで書かれている単体テストはロンドン学派からするとすべて統合テストということになる
    (本書では単体テストと統合テストの定義は古典学派の採用している)

  よって、本書では次の性質を持つテストが単体テストとなる
  - １単位の振る舞いを検証すること
  - 実行時間が短いこと
  - 他のテストケースから隔離された状態で実行されること
  こうなると、古典学派における統合テストはこれらの性質を１つでも損なっているテストのことになる
  統合テストについては第3部にて

    統合テストとは共依存や、プロセス外依存、
    さらには同じ組織内の異なるチームによって開発されたコードが統合された状態で想定通りに機能することを検証するテストのこと

*** E2E(End-to-End)テスト
    一種の統合テストとみなせる
    統合テストとの違いはプロセス外依存を多く含んでいるとE2Eになる
    統合テストは1,2個のプロセス外依存をあつかうが、E2Eでは（ほぼ）すべてを扱う
    E2Eとはエンドユーザーの視点でシステムを検証することを意味するから当然といえば当然
    そのためE2EはUIテスト、GUIテスト、機能テストとよばれることもあるが基本時に同じものを指している

    例えば、データベース、ファイルシステム、外部の決済サービスの３つのプロセス外依存を扱うアプリケーションがあるとする
    これに対して統合テストをおこなう場合、データベースとファイルシステムはそのまま使われ、外部の決済サービスをテストダブルに置き換えられる
    なぜなら、データベースとファイルシステムは開発者が自由に制御できるのでテストに合わせて状態を変えられるのに対して、外部サービスは変えられないため

* 3 単体テストの構造的解析
** 3.1 単体テストの構造
   AAAパターン（3Aパターンとも）とは、テストケースの構造に関するパターンのこと
   - 準備(Arrange)フェーズ テストケースの事前条件を満たすようにテスト対象システム(System Under Test:SUT)とその依存の状態を設定するフェーズ
   - 実行(Act)フェーズ テスト対象のメソッドを呼び出すことでテスト対象の振る舞いを実行させるフェーズ
   - 確認(Assert)フェーズ 実行結果が想定した結果であることを確認するフェーズ

   通常は準備→実行→確認という順序でテストを書いていくが、
   TDDの場合、機能開発の前にテストを書くので、想定する振る舞いをテストケースに書いておき、それを実現するためにはどうするかを考える

*** 単体テストにおいて回避すべきこと: ifの使用
    ifを使用している時点で複数の振る舞いを検証していることになり単体テストの定義から外れる

*** 各フェーズのサイズはどのくらいが適切か
    - 準備フェーズが最も大きくなる
    - 実行フェーズのコードが１行を越す場合は設計がうまくいっていないかも

    データの整合性が損なわれることは *不変条件(invariant)の侵害* とよばれる
    このような危険性からコードを守る行為が *カプセル化* になる
    たとえば、在庫にある商品の数の調整はcustomer.Purchaseメソッドの中ですべきであり、メソッドの呼び出し側が商品の数を調整するようなことを強いるべきでない
    常にActのコードが１行でないといけないわけではない（ユーティリティやインフラに関するコード）が、複数行になる場合、カプセル化が破綻していないか必ず確認すること

*** 確認フェーズで確認する項目はどのくらいあればいいのか
    1単位の振る舞いによって複数の結果が生まれるのはあり得るので１つのテストケースで複数の結果を検証するのは自然である
    ただし、確認フェーズが大きくなりすぎるのであれば、コードでの抽象化がうまくいっていない可能性が高い

    単体テストですべきことは単に何をするのか列挙するのではなく、振る舞いについて高いレベルで描写することだ

*** テストフィクスチャ
    ~ テストを実施する際に使われるオブジェクトのこと
    ~ テストフレームワークのNUnit特有のもの
      本書では１の定義を指す

*** テストメソッドに名前をつけるときの指針
**** 厳格な命名規則に縛られないようにする
      複雑な振る舞いを厳格な命名規則にしたがって表現んすることには限界があるため、そのような命名規則を強要しないことで自由な表現を可能にする
**** 問題領域のことに精通している非開発者に対してどのような検証をするのかが伝わるような名前をつける
      ここでいう非開発者とはドメイン・エキスパートやビジネスアナリストのこと
**** （英語の場合は）_を使って単語を区切るようにする


* 4 単体テストを構成する4本柱
** 退行（regression）にたいする保護
** リファクタリングへの耐性
** 迅速なフィードバック
** 保守のしやすさ

