* 1. Linuxの概要
** プログラムとプロセス
   マシンの電源を入れると、最初にカーネルが起動する。
   起動後に動作中のプログラムを *プロセス* という。
   カーネルはハードウェアの助けを借りてプロセスからデバイスに直接アクセスできないようにしている。
   具体的にCPUに備わるモードという機能を使う。
   CPUがカーネルモードであればなんの制限もないのに対し、ユーザモードで実行中ならば特定の命令を実行できないようにする、のような制約をかけられる。
   Linuxの場合はカーネルのみがこのカーネルモードで動作して、デバイスにアクセスできる。
   それに対してプロセスはユーザモードで動作するため、デバイスにアクセスできない。
   このため、プロセスは *カーネルを介して* デバイスにアクセスする。
   つまり、システム内のすべてのプロセスが享有するリソースを一元管理して、システム上で動作するプロセスに配分する
   そのためにカーネルモードで動作するプログラムが *カーネルである*。
** システムコール
   システムコールとは、 *プロセスがカーネルに処理を依頼する* ための方法である。
   新規プロセスの生成やハードウェアの操作など、カーネルの助けが必要な場合に使う。
    - プロセス生成、削除
    - メモリ確保、解放
    - 通信処理
    - ファイルシステム操作
    - デバイス操作
   などがシステムコール。
   システムコールは、CPUの特殊な命令を実行することによって実現している。
   カーネルに処理を依頼するためにシステムコールを発行すると、CPUにおいて *例外というイベント* が発生する。
   これをきっかけとして、CPUのモードがユーザモードからカーネルモードに遷移し、依頼内容に応じたカーネルの処理が動き始める。
   システムコールが終われば、ユーザモードに戻りプロセスの動作を継続する。

** ライブラリ
   多くのプログラミング言語では複数のプログラムに共通する処理をライブラリとしてまとめる機能がある。

** 標準Cライブラリ
   C言語には国際標準化機能（ISO）によって定められた標準ライブラリがある。

** システムコールのラッパー関数
   システムコールは通常の関数呼び出しと違ってC言語などの高級言語から直截呼び出せない。
   アーキテクチャ依存のアセンブリコードを使って呼び出す必要がある。
   libcは内部的にシステムコールを呼び出すだけのシステムコールのラッパーと呼ばれる一連の関数を提供している。
   高級言語で書かれたユーザプログラムからは、各言語に対して用意されているシステムコールのラッパー関数を呼び出すだけで済む。

** 静的ライブラリと共有(動的)ライブラリ
   プログラムの生成時にコンパイルしてオブジェクトファイルというファイルを作る。
   そのうえでオブジェクトファイルが使うライブラリをリンクして実行ファイルを作る。
   静的ライブラリはリンク時にライブラリ内の関数をプログラムに組み込む。
   これに対して共有ライブラリはリンク時に「このライブラリのこの関数を呼び出す」といった情報だけを実行ファイルに埋め込む。
   そのうえでプロブラムの起動時、あるいは実行中にライブラリをメモリ上にロードしてプログラムはその中の関数を呼び出す。

* プロセス管理（基礎編）
** プロセスの生成
   あたらしくプロセスを生成する目的は2つ。
   ~~ 同じプログラムの処理を複数のプロセスに分けて処理する。（例：webサーバーによる複数リクエストの受付）
   ~~ 別のプログラム生成する（例：bashから各種プログラムの新規作成）

** ゾンビプロセスと孤児プロセス
   子プロセスが終了しても親プロセスが終了状態を得ていないという状態のプロセスをゾンビプロセスという。
   システム起動中にゾンビプロセスが大量に存在している場合、親プロセスに対応するプログラムの *バグを疑う* といい。

** シグナル
   あるプロセスが他のプロセスになにかを通知して、外部から実行の流れを強制的に変えるための仕組みである。

** シェルのジョブ管理の実現
   ジョブとは、bashのようなshellがバックグラウンドで実行したプロセスを制御するための仕組み。
   セッションはユーザがgtermのような端末エミュレータ、あるはsshなどを通してシステムにログインしたときのログインセッションに対応するもの。
   すべてのセッションには、セッションを制御するための端末が紐づいている。
   セッションにはセッションID、あるいはSIDと呼ばれる一意な値が割り振られている。
   セッションリーダーというプロセスが１つ存在していて、通常はbashなどのshellになる。

** プロセスグループ
   プロセスグループは、復数のプロセスをまとめてコントロールするためのもの。
   セッションの中には復数のプロセスグループが存在する。

** デーモン
   デーモンは常駐プロセスのこと。
   普通のプロセスはユーザが立ち上げてから何らかの一連の処理をしてから終了することが前提。
   デーモンはシステムの開始から終了まで存在し続ける。
   デーモンの特徴は
   - 端末から入出力する必要がないので、端末が割り当てられていない。
   - あらゆるログインセッションが終了しても影響を受けないように、独自のセッションを持つ。
   - デーモンを生成したプロセスがデーモンの終了を気にしなくていいように、initが親になっている。
   上記の条件に当てはまらないものも、常駐プロセスであれば便宜的にデーモンと呼ばれることもある。

* プロセススケジューラ
  システムに存在するプロセスは、ほとんどスリープ状態だが、ではシステムに複数の実行可能プロセスが存在する場合、カーネルはどのように各プロセをCPU上で実行させるのだろう？

** コンテキストスイッチ
   論理CPU上で動作するプロセスが切り替わることをコンテキストスイッチという。
   コンテキストスイッチは、プロセスがいかなるコードを実行中であろうとも、タイムスライスが切れると容赦なく発生する。
   なので、例えばfoo()の直後にbar()が実行されるという保証はない。
   foo()の実行直後にタイムスライスが切れた場合、bar()の実行はそのしばらくあとになる。
   これを理解していると、ある処理の完了までに想定より多くの時間がかかってしまった場合に、「その処理自体に問題があるに違いない」と安易に結論づけるのではなく
   「処理中にコンテキストスイッチが発生して他のプロセスが動いた可能性もある」という別の観点を持てる。

** 性能について
   - ターンアラウンドタイム: システムに処理を依頼してから個々の処理が終わるまでの時間
   - スループット: 単位時間当たりに処理を終えられる数
   応答性能重視のシステムは、スループット重視のシステムよりも、システムを構成する各マシンのCPU使用率を低めに抑える必要がある。
   論理CPUをたくさん積んでいるマシンがあったとしても、そこに十分な数のプロセスを実行させてはじめてスループットが向上する。
   むやみにプロセス数を増やしてもスループットは上がらない。

* メモリ管理システム
** メモリ関連情報の取得
   システムが搭載するメモリの量と使用中のメモリの量はfreeコマンドで得られる。

** 仮想記憶
   仮想記憶はハードウェアとソフトウェア（カーネル）の連携によって実現している。

   ページテーブル 仮想アドレス→物理アドレス
   CPUがメモリをぺーじ単位で管理
   ページテーブルエントリ 仮想アドレスと物理アドレスの対応表
   ページのサイズはCPUアーキテクチャごとに異なる
   ページテーブルはカーネルがつくる

   *カーネル*
   -- プロセス生成 ＋ プロセス用のページテーブル作成
   *CPU*
   - プロセスが仮想アドレスへアクセス -> 物理アドレスへ変換

   仮想アドレス空間は固定でページテーブルエントリにはページに対応する物理アドレスが存在するかどうかを示すデータがある。
   なので、物理アドレスに紐づいていないアドレスにプロセスがアクセスすると、CPU上で *ページフォールト* という例外が発生する。
   この例外によって、CPU上で実行中の命令が中断され、カーネールのメモリに配置された *ページフォールトハンドラ* という処理が実行される。

   カーネルはページフォールトにおいてプロセスによるそのメモリアクセスが不正であることを検出する。
   →SIGSEVというシグナルをプロセスに送信
   →SIGSEVを受け取ったプロセスは強制終了させられる
   その内容を実装したCの実行結果は *Segmention fault*


*** 仮想記憶がないときの課題
    仮想記憶がないときのメモリ管理には、以下のような課題がある。
    -  メモリの断片化
    - マルチプロセスの実現が困難
    - 不正な領域へのアクセス

**** メモリの断片化
     プロセスが生成されたあとに、メモリの獲得、開放を繰り返すとメモリの断片化という問題が発生する。
     例えば、300バイトも空いているのに、まとまっていないため、100バイトずつ３つの領域に分かれていると100バイトより大きな領域の確保に失敗する。

**** 不正な領域へのアクセス
     カーネルやたくさんのプロセスがメモリ上に配置されている場合、あるプロセスがカーネルや他のプロセスに割当てられたメモリのアドレスを指定すればそれらの領域にアクセスできてしまう。
     そのため、データの漏洩や破壊のリスクがある。

*** 仮想記憶の機能
    仮想記憶はプロセスがメモリアクセスする際にシステムに搭載されているメモリに直接アクセスさせるのではなく、仮想アドレスというアドレスを用いて間接的にアクセスさせるという機能。
**** ページテーブル
     仮想アドレスから物理アドレスへの変換にカーネルのメモリ内に保存されている「ページテーブル」という表を使う。
     ページテーブルを作るのはカーネル。

*** 仮想記憶による課題の解決
    - メモリの断片化
      プロセスのページテーブルをうまく設定すれば、物理メモリ上では断片化している領域を、プロセスの仮想アドレス空間上では大きな一つの領域として見せられる。
      これによって断片化の問題を解消される。

    - マルチプロセスの実現が困難
      仮想アドレス空間はプロセスごとに作られるので、マルチプロセス環境において各プログラムは、ほかのプログラムとのアドレスの重複を避けられる。

    - 不正な領域医へのアクセス
      プロセスごとに仮想アドレス空間があるということは、他のプロセスのメモリにはそもそもアクセスできないということ。
      あるプロセスから別のプロセスへの不正アクセスができなくなる。

** プロセスへの新規メモリの割り当て
   ~ メモリ領域の割り当て：仮想アドレス空間に新規にアクセス可能なメモリ領域をマップする。
   ~ メモリの割り当て： 上記メモリ領域に物理メモリを割り当てる。

   *ページフォールトハンドラ*
   - if ページテーブルエントリが存在する -> 物理アドレスが割り当てられていない場合 ->カーネルが新規メモリを割り当てる
   - if ページテーブルエントリが存在しない -> SIGSEVをプロセスへ

** ページテーブルの階層化
   ページテーブルはメモリ使用量を削減するために階層化される

   *ヒュージページ*
   通常サイズより大きいページでメモリ削減できる。
   データベースや仮想マシンマネージャなど仮想メモリを大量に使うソフトウェアにはヒュージページを使う設定が用意されている。


* プロセス管理
** プロセス間通信
   復数のプログラムを強調動作させるにはお互いの処理のタイミングを合わせる（同期させる）必要がある。
   このためにOSが提供する機能を *プロセス間通信* という。

